<!doctype html>
<html lang="sk">
  <head>
    <meta charset="utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="SPy o.z.">
    <link rel="icon" href="/static/img/logo/favicon.ico" sizes="16x16">
    <title>Print: Učíme s Hardvérom</title>
    <link href="/static/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/static/css/python.css" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  </head>

  <body>

    <main role="main">

      <div class="container">
            <h1>Displej - menovka</h1>
            <div class="alert alert-warning">
<p class="h4">Pracujeme...</p>
<p>Táto kapitola je ešte rozpracovaná, zatiaľ tu nájdeš iba základné informácie. V najbližšom čase ju budeme ešte dopĺňať.</p>
</div>
<h2 id="menovka">Menovka</h2>
<p>Ako si si mohol/mohla všimnúť, micro:bit má na svojej prednej strane 5x5 červených LED diód. MicroPython Ti dáva viacero možností, akými na displeji niečo vykreslovať či vypisovať.</p>
<p>Najbežnejším prvým programom pri učení sa nového programovacieho jazyka býva vypísanie textu "Ahoj, Svet!". </p>
<p>V MicroPythone vieme napísať tento program v dvoch riadkoch kódu:</p>
<pre><code>from microbit import display
display.scroll("Ahoj, Svet!")
</code></pre>
<p>Každý riadok vykaná niečo iné. Prvý riadok:</p>
<pre><code>from microbit import dispay
</code></pre>
<p>povie micro:bitu, aby pre nás pripravil funkcionalitu <code>display</code> z modulu <code>microbit</code>. Tento modul obsahuje predprogramované funkcie, ktoré ovládajú napríklad zobrazovanie textu na obrazovke. Takéto 'zavolanie' voláme <code>import</code>. Moduly sa taktiež niekedy nazývajú aj knižnicami (no namiesto kníh majú v sebe kód).</p>
<p>Druhý riadok:</p>
<pre><code>display.scroll("Ahoj, Svet!")
</code></pre>
<p>povie micro:bitu, aby na displej postupne vypísal reťazec znakov "Ahoj, Svet!". Slovo <code>display</code> je objekt z modulu <code>microbit</code>, ktorý predstavuje fyzický displej zariadenia (hovoríme „objekt“ namiesto „hento“, „oné“ alebo „tá vec“). Za objekt sme napísali bodku, za ktorou nasleduje príkaz (po správnosti nazývaný <code>metóda</code>). V tomto prípade používame metódu <code>scroll</code>, čo po slovensky znamená posúvať. Aby ale micro:bit vedel, aký text má na obrazovke posúvať, musíme ho označiť pomocou dvojitých úvodzoviek <code>"</code> (na začiatku a aj na konci) a poslať do príkazu scroll. To spravíme vložením textu do  zátvoriek za metódou <code>scroll()</code>. Obsah zátvoriek nazývame argument. Takže display.scroll("Ahoj, svet!") znamená po slovensky „Chcem, aby si použil displej a posúval na ňom text ‚Ahoj, svet!‘“. Ak metóda nepotrebuje argumenty, musíme to dať jasne najavo použitím prádznych zátvoriek - takto: <code>scroll()</code>.</p>
<p>Teraz svoj kód ešte skontroluj - či už opticky, alebo v <code>Mu editore</code> pomocou tlačidla <code>check</code> (veľký palec). Ak si v programe nenašiel žiadne chyby, nahraj ho na micro:bit (v Mu editore pomocou tlačidla <code>Flash</code>).</p>
<p>Ak by si chcel zistiť, aké iné argumenty môžeš pre príkaz <code>scroll()</code> použiť, pozri si <a href="https://microbit-micropython.readthedocs.io/en/latest/display.html?highlight=scroll#microbit.display.scroll&gt;">dokumentáciu</a></p>
<div class="alert alert-warning">
<p class="h4">Warning</p>
<p>Je možné, že Ti program nebude fungovať hneď na prvý krát. Nezľakni sa, ani skúseným programátorom väčšinou nevýjde všetko hneď na prvý krát.</p>
</div>
<div class="alert alert-primary">
<p class="h4">Úloha č. 1</p>
<p>Pozmeň program tak, aby si z neho spravil digitálnu menovku a vypisoval Tvoje (krstné) meno.</p>
</div>
<div class="alert alert-primary">
<p class="h4">Úloha č. 2</p>
<p>Doplň program tak, aby okrem Tvojho mena zobrazoval aj to, v ktorom meste bývaš. Výsledný program by mal mať 3 riadky kódu (vrátane riadka, kde importujeme).</p>
</div>
<div class="alert alert-primary">
<p class="h4">Kontrolné otázky</p>
<ul>
<li>Čo je to argument metódy?</li>
<li>Ak do metódy neposielam žiadne argumenty, musím písať zátvorky?</li>
</ul>
</div>
<h2 id="trvale-zobrazovanie-textu">Trvalé zobrazovanie textu</h2>
<p>Podarilo sa nám text vypísať na obrazovku, avšak zatiaľ sa vždy vypíše iba jeden krát. No čo ak si chceme spraviť menovku, ktorá by stále ukazovala Tvoje krstné meno? Potrebujeme nejakým spôsobom docieliť, aby sa náš riadok kódu s príkazom <code>display.scroll()</code> donekonečna spúšťal. Môžme skúsiť daný riadok skopírovať čo najviac krát::</p>
<pre><code>from microbit import display
display.scroll("Volam sa Marek")
display.scroll("Volam sa Marek")
display.scroll("Volam sa Marek")
display.scroll("Volam sa Marek")
display.scroll("Volam sa Marek")
# atď.
</code></pre>
<p>ale aj tak sa raz vykonávanie programu skončí. Potrebujeme preto nekonečný cyklus::</p>
<pre><code>from microbit import display
while True:
    display.scroll("Volam sa Marek")
</code></pre>
<p>Príkaz <code>while</code> sa vždy pozerá na to, čo sme napísali za neho. Pokým je za ním pravdivá hodnota tak bude vykonávať všetky príkazy prislúchajúce do daného cyklu. A keďže <code>True</code> (anglicky <code>pravda</code>) je vždy pravdivé, tak micro:bit bude kód opakovať donekonečna. To, či nejaký kód patrí do cyklu zistíš tak, že ďaľšie riadky sú posunuté do prava o 4 medzerníky (jeden tabulátor - kláves nad CapsLock-om). Toto posunutie sa po slovensky volá <code>odsadenie</code> a po anglicky <code>indentation</code> čiže <code>indentácia</code>.</p>
<p>Všimni si, že na konci riadku s príkazom <code>while</code> sa nachádza dvojbodka. Tá sa vždy používa v kombinácií s príkazmi, po ktorých aspoň jeden ďaľší príkaz odsadíš a bude sa vykonávať na základe toho, aká je podmienka v riadku s dvojbodkou.</p>
<p>Pozrime sa teraz na tento kód:</p>
<pre><code>from microbit import display
while True:
    display.scroll("Marek")
    display.scroll("Z Bratislavy")
display.scroll("toto sa nikdy nevypise")
</code></pre>
<p>Z kódu vieme vyčítať, že donekonečna budeme vypisovať "Marek" a "z Bratislavy". Príkaz s textom "toto sa nikdy nevypise" nie je odsadený, a tak nie je súčasťou while cyklu. Preto by sa vykonal až keď while cyklus skončí. Ten ale nikdy neskončí, keďže <code>True</code> má vždy pravdivú hodnotu, a tak sa tento riadok kódu nikdy nespustí.</p>
<p>Kým v predchádzajúcej ukážke sa posledný riadok kódu nikdy nespustí, aspoň sa nám zobrazovali príkazy "Marek" a "z Bratislavy". Čo ak by sme ale doplnili takýto riadok:</p>
<pre><code>from microbit import display
while True:
    display.scroll("Marek")
    display.scroll("Z Bratislavy")
display.scroll("toto sa nikdy nevypise")
    display.scroll("dalsi riadok")
</code></pre>
<p>V tomto prípade by nám program vôbec nespustil a vypísal by chybu, pretože posledný riadok je odsadený aj keď by nemal byť.</p>
<div class="alert alert-primary">
<p class="h4">Chyby sú bežné...</p>
<p>Skús spustiť posledný kód (s nesprávnym odsadzovaním) a zistiť, aký chybu vypíše micro:bit na displej.</p>
</div>
<div class="alert alert-primary">
<p class="h4">Kontrolné otázky</p>
</div>
<ul>
<li>O koľko medzerníkov sa odsadzuje príkaz patriaci do cyklu?</li>
<li>Na čo v nekonečnom cykle využívame príkaz <code>True</code>?</li>
<li>Koľko najviac príkazov za sebou môže byť v jednom nekonečnom cykle?</li>
</ul>
<h2 id="pauza-medzi-vypisovanim-textu">Pauza medzi vypisovaním textu</h2>
<p>Čo ak by sme chceli medzi dva výpisy textu na obrazovku pridať nejakú pauzu, napríklad 5 sekúnd? Využijeme príkaz, ktorý micro:bitu povie, aby chvíľu počkal::</p>
<pre><code>from microbit import display, sleep

display.scroll("Ahoj")
sleep(5000)
display.scroll("Ako sa mas?")
</code></pre>
<p>Príkaz <code>sleep()</code> sme vložili medzi dva výpisy textu, a tak sa najprv zobrazí text "Ahoj", chvíľu počká a potom vypíše text "Ako sa mas?". To, ako dlho má čakať povieme micro:bitu pomocou argumentu, ktorý napíšeme do zátvoriek za metódou <code>sleep</code>. Tento krát vkladáme číslo a nie reťazec, preto nepoužívame úvodzovky <code>"</code>. Napíšeme tam, koľko milisekúnd má micro:bit čakať. Jedna milisekunda je tisícina sekundy, 1000 milisekúnd je 1 sekunda a 5000 milisekúnd je 5 sekúnd, čiže náš kód počká 5 sekúnd.</p>
<div class="alert alert-primary">
<p class="h4">Úlohy</p>
<ul>
<li>Využi príkaz <code>sleep()</code> v nekonečnom cykle.</li>
<li>Uprav nasledujúci kód tak, aby micro:bit vypísal "Ahoj Martin", počkal 3 sekundy, vypísal "Ahoj Vanessa" a zas počkal 3 sekundy::</li>
</ul>
</div>
<pre><code>from microbit import display

while True:
    display.scroll("Ahoj Martin")
    display.scroll("Ahoj Vanessa")
</code></pre>
<div class="alert alert-primary">
<p class="h4">Kontrolné otázky</p>
<ul>
<li>Čo sa stane, ako použijeme viac príkazov <code>sleep()</code> za sebou?</li>
<li>Akú chybu vypíše micro:bit ak by sme namiesto čísla poslali to metódy <code>sleep</code> reťazec označený úvodzovkami (napríklad <code>sleep("5000")</code>)?</li>
</ul>
</div>
<p>Posledná zmena: <strong>28.2.2020</strong></p>
      </div>

    </main>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script>window.jQuery || document.write('<script src="/static/js/vendor/jquery-slim.min.js"><\/script>')</script>
    <script src="/static/js/vendor/popper.min.js"></script>
    <script src="/static/bootstrap/js/bootstrap.min.js"></script>
    <script src="/static/js/vendor/holder.min.js"></script>


    <script>

      /* message signatures
      export interface RenderBlocksRequestMessage extends SimulatorMessage {
          type: "renderblocks",
          id: string;
          code: string;
          options?: {
              package?: string;
              packageId?: string;
              snippetMode?: boolean;
          }
      }

      export interface RenderBlocksResponseMessage extends SimulatorMessage {
          source: "makecode",
          type: "renderblocks",
          id: string;
          svg?: string;
          width?: number;
          height?: number;
      }*/

      var makeCodeRenderPre = makeCodeRenderPre || (function () {
          // pre waiting to be rendered
          // when undefined, iframe is loaded and ready
          var pendingPres = [];
          function injectRenderer() {
              var f = document.getElementById("makecoderenderer");
              // check iframe already added to the DOM
              if (f) {
                  return;
              }
              var f = document.createElement("iframe");
              f.id = "makecoderenderer";
              f.style.position = "absolute";
              f.style.left = 0;
              f.style.bottom = 0;
              f.style.width = "1px";
              f.style.height = "1px";
              f.src = "https://makecode.microbit.org/--docs?render=1"
              document.body.appendChild(f);
          }

          function renderPre(pre) {
              console.log('render ' + pre.id)
              var f = document.getElementById("makecoderenderer");
              // check if iframe is added and ready (pendingPres is undefined)
              if (!f || !!pendingPres) {
                  // queue up
                  pendingPres.push(pre);
                  injectRenderer();
              } else {
                  f.contentWindow.postMessage({
                      type: "renderblocks",
                      id: pre.id,
                      code: pre.innerText,
                      options: {
                        packageId: pre.getAttribute("data-packageid")
                      }
                  }, "https://makecode.microbit.org/");
              }
          }

          // listen for messages
          window.addEventListener("message", function (ev) {
              var msg = ev.data;
              if (msg.source != "makecode") return;

              console.log(msg.type)
              switch (msg.type) {
                  case "renderready":
                      // flush pending requests                   
                      var pres = pendingPres;
                      // set as undefined to notify that iframe is ready
                      pendingPres = undefined;
                      pres.forEach(function (pre) { renderPre(pre); })
                      break;
                  case "renderblocks":
                      var svg = msg.svg; // this is an string containing SVG
                      var id = msg.id; // this is the id you sent

                      var xhttp = new XMLHttpRequest();
                      xhttp.open("POST", "http://127.0.0.1:5000/materialy/save_makecode_image/"+msg.id, true);
                      xhttp.send(msg.uri);


                      // replace text with svg
                      var img = document.createElement("img");
                      img.src = msg.uri;
                      img.width = msg.width;
                      img.height = msg.height;
                      var code = document.getElementById(id);
                      code.parentElement.insertBefore(img, code)
                      code.parentElement.removeChild(code);
                      break;
              }
          }, false);

          return renderPre;
      })();

      function renderSnippets() {
          // TODO ADD RENDER LOGIC HERE
          let pres = document.getElementsByTagName("pre");
          Array.prototype.forEach.call(pres, function (pre) {
              makeCodeRenderPre(pre);
          })
      }

      // load the renderer
      renderSnippets();

      </script>

  </body>
</html>